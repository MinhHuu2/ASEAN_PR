from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
from bs4 import BeautifulSoup
import time
from selenium.webdriver.chrome.options import Options
from datetime import datetime
from dateutil.relativedelta import relativedelta
import pandas as pd
import numpy as np
# (Phần CẤU HÌNH CHROME, HÀM ĐÓNG IFRAME QUẢNG CÁO, HÀM CRAWL MỘT Indicators)

# =====================================================
# CẤU HÌNH CHROME
# =====================================================
def create_driver():
    chrome_options = Options()
    chrome_options.add_argument("--headless=new")
    chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-extensions")
    chrome_options.add_argument("--disable-popup-blocking")
    chrome_options.add_argument("--disable-notifications")

    prefs = {
        "profile.managed_default_content_settings.images": 2,
        "profile.managed_default_content_settings.stylesheets": 2,
        "profile.managed_default_content_settings.cookies": 2,
        "profile.managed_default_content_settings.fonts": 2,
    }
    chrome_options.add_experimental_option("prefs", prefs)

    chrome_options.add_argument(
        "user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    )

    driver = webdriver.Chrome(options=chrome_options)
    driver.set_page_load_timeout(60)
    return driver


# =====================================================
# HÀM ĐÓNG IFRAME QUẢNG CÁO
# =====================================================
def close_ads_iframe(driver):
    try:
        iframe = driver.find_element(By.CSS_SELECTOR, "iframe[id^='lightbox-iframe']")
        driver.execute_script("arguments[0].style.display='none';", iframe)
    except:
        pass

# Ngày giới hạn = hôm nay - 24 tháng
limit_date = datetime.today() - relativedelta(months=24)

# =====================================================
# HÀM CRAWL MỘT Indicators
# =====================================================
def crawl_indicator(indicator_name, indicator_id):
    url = f"https://vn.investing.com/economic-calendar/{indicator_name}-{indicator_id}/"
    BUTTON_ID = f"showMoreHistory{indicator_id}"
    LOADER_ID = f"showMoreHistoryLoader{indicator_id}"

    driver = create_driver()
    driver.get(url)
    wait = WebDriverWait(driver, 20)

    stop = False
    results = []
    processed_dates = set()
    table_headers = None
    release_header_text = None

    print(f"\n=== THU THẬP: {indicator_name.upper()} (ID {indicator_id}) ===")

    while not stop:
        # --- CLICK LOAD MORE ---
        try:
            close_ads_iframe(driver)
            load_more = wait.until(EC.element_to_be_clickable((By.ID, BUTTON_ID)))
            driver.execute_script("arguments[0].scrollIntoView(true);", load_more)
            time.sleep(0.4)
            driver.execute_script("arguments[0].click();", load_more)

            wait.until(EC.invisibility_of_element_located((By.ID, LOADER_ID)))
            time.sleep(0.8)

        except TimeoutException:
            print("⛔ Không còn dữ liệu để load. Kết thúc.")
            break
        except WebDriverException:
            print("⚠️ Lỗi mạng. Reload...")
            driver.refresh()
            time.sleep(3)
            continue

        # --- PARSE HTML ---
        soup = BeautifulSoup(driver.page_source, "html.parser")

        # Lấy header "Ngày phát hành"
        if release_header_text is None:
            th = soup.find("th", class_="left symbol noWrap")
            if th:
                release_header_text = th.text.strip()

        table = soup.find("table", class_="genTbl openTbl ecHistoryTbl")
        if not table:
            continue

        # Header bảng
        if table_headers is None:
            header_row = table.find("tr")
            table_headers = [th.text.strip() for th in header_row.find_all("th")]
            print("HEADER:", table_headers)

        # --- DUYỆT DỮ LIỆU ---
        for row in table.find_all("tr")[1:]:
            cols = row.find_all("td")
            if len(cols) < 5:
                continue

            date = cols[0].text.strip()
            actual = cols[2].text.strip()
            forecast = cols[3].text.strip()
            previous = cols[4].text.strip()

            try:
                current_date = datetime.strptime(date.split()[0], "%d/%m/%Y")
            except:
                continue

            # STOP nếu < limit_date (24 tháng)
            if current_date < limit_date:
                stop = True
                break

            if date not in processed_dates:
                # Sử dụng header tiếng Việt đã làm sạch từ table_headers
                record = {
                    release_header_text: date,
                    table_headers[2]: actual,
                    table_headers[3]: forecast,
                    table_headers[4]: previous
                }
                results.append(record)
                processed_dates.add(date)

    driver.quit()

    print(f"✔ Thu được {len(results)} bản ghi cho {indicator_name.upper()}.")
    return results




# =====================================================
# DANH SÁCH NHIỀU Indicators
# =====================================================
indicators = {
    733: "cpi",
    375: "gdp",
    173: "ism-manufacturing-pm",
    256: "retail-sales"
}

# =====================================================
# GỌI TOÀN BỘ VÀ XỬ LÝ DỮ LIỆU
# =====================================================

all_data = {}

for ind_id, ind_name in indicators.items():
    data = crawl_indicator(ind_name, ind_id)
    all_data[ind_name.upper()] = data

print("\n=== HOÀN THÀNH THU THẬP DỮ LIỆU VĨ MÔ ===")

# --- 1. GHÉP NỐI DỮ LIỆU VÀ TẠO DATAFRAME TỔNG HỢP ---
all_records = []
for ind_name, data_list in all_data.items():
    for record in data_list:
        record['Indicators'] = ind_name.upper()
        all_records.append(record)

df_events = pd.json_normalize(all_records) 

# Hàm làm sạch header và đổi tên cột
def clean_col_name(col):
    if isinstance(col, str):
        return col.strip().replace('\n', ' ').replace('\xa0', ' ').strip()
    return col

df_events.columns = [clean_col_name(col) for col in df_events.columns]

# Đổi tên cột 
df_events = df_events.rename(columns={
    'Thực tế': 'Actual', 
    'Dự báo': 'Forecast', 
    'Trước đó': 'Previous', 
    'Ngày Phát Hành': 'Release Date'
})

# --- 2. LÀM SẠCH VÀ CHUYỂN ĐỔI GIÁ TRỊ 

# Hàm làm sạch giá trị (giữ nguyên)
def clean_value(value):
    if pd.isna(value) or value == '':
        return np.nan
    
    # Loại bỏ % và , (phẩy)
    value = str(value).replace('%', '').replace(',', '').strip()
    
    # Xử lý K, M, B (Giữ nguyên logic)
    if value.endswith('K'): return float(value[:-1]) * 1000
    if value.endswith('M'): return float(value[:-1]) * 1000000
    if value.endswith('B'): return float(value[:-1]) * 1000000000
    try: return float(value)
    except ValueError: return np.nan

# Áp dụng hàm làm sạch 
df_events['Actual'] = df_events['Actual'].apply(clean_value)
df_events['Forecast'] = df_events['Forecast'].apply(clean_value)
df_events['Previous'] = df_events['Previous'].apply(clean_value)


# --- 3. TÍNH TOÁN ĐỘ LỆCH VÀ PHÂN LOẠI TÁC ĐỘNG ---

# Tính Deviation
df_events['Deviation'] = df_events['Actual'] - df_events['Forecast']

def assess_impact_for_macro(row):
    deviation = row['Deviation']
    index = row['Indicators']
    
    # CPI: Lệch âm (Actual < Forecast) = Positive
    if index == 'CPI': return 'Positive' if deviation < 0 else 'Negative'
    # GDP, PMI, Retail: Lệch dương (Actual > Forecast) = Positive
    elif index in ['GDP', 'ISM-MANUFACTURING-PM', 'RETAIL-SALES']:
        return 'Positive' if deviation > 0 else 'Negative'
    return 'Neutral'

df_events['Impact (Trend)'] = df_events.apply(assess_impact_for_macro, axis=1)

# --- 4. LƯU FILE ---
df_final_events = df_events[[
    'Release Date',
    'Indicators', 
    'Actual', 
    'Forecast', 
    'Previous',
    'Deviation', 
    'Impact (Trend)'
]].sort_values(by='Release Date', ascending=False)

df_final_events.to_csv('macro_events_summary_history.csv', index=False)
print(f"\n✅ Đã tạo file 'macro_events_summary_history.csv'.")

------------------------------------------- Dữ liệu thị trường ----------------------------------------------------

import yfinance as yf
import pandas as pd
from datetime import datetime
from dateutil.relativedelta import relativedelta 
import numpy as np
import os

# --- 1. THAM SỐ VÀ TẢI DỮ LIỆU LỊCH SỬ (24 THÁNG) ---
end_date = datetime.now().strftime('%Y-%m-%d')
start_date = (datetime.now() - relativedelta(months=24)).strftime('%Y-%m-%d') 

# Ticker cho 3 chỉ số cần 24 tháng
tickers_market = {
    'S&P 500': '^GSPC',
    'DXY Index': 'DX-Y.NYB',
    'USD/VND Rate': 'VND=X'
}

print(f"Bắt đầu tải dữ liệu thị trường từ ngày: {start_date}...")

# Khởi tạo DataFrame rỗng để gộp dữ liệu
df_market = pd.DataFrame() 

# --- SỬA ĐỔI: Tải Từng Ticker một để đảm bảo không nhầm lẫn cột ---
for name, ticker in tickers_market.items():
    print(f"-> Tải dữ liệu cho {name} ({ticker})...")
    
    # 1. Tải dữ liệu, chỉ lấy cột Close
    data = yf.download(ticker, start=start_date, end=end_date)['Close']
    
    # 2. Chuyển Series thành DataFrame và đổi tên cột
    df_temp = pd.DataFrame(data)
    df_temp.columns = [name]

    # 3. Gộp vào DataFrame chính
    if df_market.empty:
        df_market = df_temp
    else:
        df_market = df_market.join(df_temp, how='outer')

# Xử lý các ngày nghỉ (điền giá trị gần nhất) và loại bỏ dòng rỗng
df_market = df_market.ffill().dropna()

# Lưu file cuối cùng
df_market.to_csv('market_trends_history_24m.csv', index=True, index_label='Date')
print("Tạo 'market_trends_history_24m.csv' thành công.")
